Design document answer following questions:

1) How many threads are you going to use?
	Specify the work each thread is intended to perform.

-> One main thread: parse input file, create threads, start timer.
	thread is idle during simulation, it just performs setup/cleanup.

-> One controller thread: Global scheduler, it will decide which train will
	enter the main track and signals it to enter. It will wait for the
	train to cross before allowing the next one.

-> n train threads: One thread per train, each simulates a single train.
	It will load (sleep during load), add to station queue, cross (sleep),
	and then finish and signal controller that it is done.
	Then terminate.

-> Therefore a total of (2+n) threads. 


2) Do the threads work independently? Or, is there a "controller" thread?
	
->	1 controller thread to manage the main track sending and waiting.
	Train threads will do their own work (loading, queueing, waiting)
	But the controller thread will decide when they cross. It will
	maintain the priority rules and signals exactly one train at a time.


3) How many mutexes are you going to use?
	Specify the operation that each mutex will guard.

->	4 Station mutex - mutex will protect station queues
		There will be four queues for each type of priority
		i.e high & low, east & west.
		Therefore, each queue must get its own mutex.

	1 Main track mutex - protects access to the main track state.
		Used to indicate to the controller when it can or cannot 
		send a train.	


4) Will the main thread be idle? if not, what will it be doing?
	
	The main thread will be idle. It will perform setup and cleanup.
	While the train simulation is running it will be standing by idle.


5) How are you going to represent stations (loaded trains ready to depart)?
	What type of data structure will you use?

	Stations will be a queue of Train structs.
	The train structs will store id, priority, direction, 
		load/cross time.
	

6) How are you going to ensure that data structures in your program
	will not be modified concurrently?

	The station mutexs protecting each queue will ensure that the data
	will not be modified concurrently. The train structs stored inside,
	will never be modified so they do not need a mutex.


7) How many convars are you going ot use? For each convar:
	~ Describe the condition it will represent.
	~ Which mutex is associated with the convar? why?
	~ What operation should be performed one pthread_cond_wait() has be unblocked
		and re-acquired the mutex?

	4 convars for each queue: 
	Each station will have a convar that signals a train is now waiting
	in the queue.

	The controller waits until any queue has a train ready.
	When a train thread finishes loading, it locks its station mutex,
	pushes itself onto the queue, and then calls pthread_cond_signal()
	on that queues convar to notify the controller.
	Each station convar is paried with that stations mutex because
	they are both related ot that stations queue.

	After pthread_cond_wait(): the controlller should check the queue,
	if not empty, select next train and signal it to cross the track.	


	1 convar for main track:
	The main track will have a convar that signals the main track
	is now free for the next train.

	After the controller lets a train onto the track, it must wait
	for the train to cross. The train thread signals the controller
	once it is done crossing.

	It will be paried with the mai ntrack mutex since that mutex protects
	the tracks state.

	After pthread_cond_wait() the controller should lock the track mutex,
	check if the track is free, then choose and signal next train to cross.


8) Briefly sketch the overall algorithm you will use. Use sentences.

	Main thread:
	parse input, create mutex and convars, create controller thread,
	create n train threads, join dispatcher thread.


	Train thread:
	sleep(load_time), locks station queue mutex, push onto queue, 
	wake dispatcher with convar using pthred_cond_signal(),
	wait for signal to cross, sleep(cross-time), signal controller
	that the track is now free.

	Controller thread:
	Wait until any queue has a train read using pthread_cond_wait(),
	select next train to cross (following rules), signal train to cross,
	wait for train thread to signal that is is done crossing, repeat 
	until no trains left.
